---
title: "A Hands-On Introduction to Polyglot Files"
date: 2025-12-08 00:00:00 +0800
categories: [File Upload, Polyglots]
author: "Felipe Raczkowski Anaya"
---

The goal of this post is to explore the nature of polyglot files and the scenarios where they are most effective for discovering vulnerabilities. We will also explore two existing tools which are going to help us create these kinds of files.

Learning the basics and how to use tools is valuable. However I firmly believe that taking that extra step to thoroughly understand the underlying mechanics, what they are actually doing and why, leads to a much deeper comprehension of any topic. This is exactly why I wanted to break this topic down step by step and with as much detail as possible.

# Polyglots
Starting with the main concept, these files are created by carefully structuring data so that different parsers interpret the same file differently. For example, a .png image might contain a hidden .exe payload, allowing it to behave as either an image or an executable depending on the context. This technique is commonly seen in malware distribution, but it’s also useful for bypassing file upload filters or exploiting weaknesses in file parsers.

Polyglot files work because attackers take advantage of overlaps between file formats and the way real-world parsers handle headers and structure. This becomes easier when a format tolerates extra bytes before or after the “content”, or when its signature doesn’t have to appear exactly at byte zero (that is the case, for example, of HTML). That said, the trick doesn’t depend on the embedded payload being a format with no magic bytes; it depends on making both parsers accept the same byte sequence.

## Where polyglot uploads become risky

Polyglot upload testing is most valuable when the uploaded file is interpreted, transformed, or re-used by one or more components: server-side, client-side, or both. In practice, these processing paths are often not obvious from the outside, so it’s reasonable to prioritize testing whenever any of the following seem plausible:

- When an uploaded image or PDF is handled by image processing libraries or document parsers (CVE-2016–3714, CVE-2024–34790, CVE-2025–5138)

- When the metadata contained in a file is processed or manipulated by the server after the upload (CVE-2021–22204)

- When the file and, as a consequence, its extension, can be modified after it has been uploaded (CVE-2020–36847)

## Examples and Useful tools to create polyglot files

### Mitra

This tool automates the creation of polyglot files. It detects the two formats being combined, analyzes their structure and magic bytes, and identifies the chunks or segments each format allows. Based on that, it generates combinations where both formats can coexist within a single file. The tool supports the creation of these four categories of polyglots:

- **Stacks**: Simply appends one file after the other. Each parser reads only the part it recognizes and ignores the rest.

- **Parasites**: Injects file 2 into a location inside file 1 that allows arbitrary data without breaking its structure. This works if file1 has flexible or unused chunks.

- **Zippers**: Builds a file that is valid for both parsers simultaneously. It is created by overlapping the structures of file 1 and file 2, effectively “zipping” both formats together. The result is a more complex structure compared to parasite files.

- **Cavities**: Leverages “empty” or unused spaces within the primary file format to inject content from a second format. These spaces don’t affect the validity of the original file and can be used to hide or embed payloads.

As an example, we are going to create a PNG file which has an HTML embedded inside.

After executing Mitra, it shows that it was possible to create 2 types of combinations, a stack and a parasite file.

![Primera imagen](/assets/img/Polyglot-Post/image1.png)

By inspecting the parasite file, it embedded the HTML file inside the PNG without corrupting it, using a “cOMM” chunk.

![Segunda imagen](/assets/img/Polyglot-Post/image2.png)

Let’s dive into why Mitra created this file the way it did, and why it can be interpreted in two completely different ways just by changing its extension.

According to the official PNG specification (RFC 2083), we know that this “cOMM” chunk is considered ancillary because its first character is lowercase (‘c’), which sets the ancillary bit to 1 [3.3 – Chunk Naming Conventions](https://datatracker.ietf.org/doc/html/rfc2083#page-13). Mitra simply took advantage of this and injected the payload inside this chunk.

Ancillary chunks are blocks of data whose contents are not strictly required to reconstruct or display the main image, and they can hold additional information while still keeping a valid PNG format [4.2 – Ancillary Chunks](https://datatracker.ietf.org/doc/html/rfc2083#page-19).

But here’s the interesting part: the “cOMM” chunk used here is not one of the officially defined ancillaries in the RFC.

**So… what’s going on here??**
This is where the magic happens: since “cOMM” is not part of the standard PNG specification, decoders will safely ignore any unknown ancillary chunk types and continue rendering the image normally [12.12 – Chunk Layout](https://datatracker.ietf.org/doc/html/rfc2083#page-77)

This behavior makes it possible to embed additional data such as an entire HTML file inside such a chunk without affecting how the image is rendered. As a result, the PNG remains visually intact, but it secretly carries an extra payload that may be interpreted differently depending on how the file is served or processed.

In contrast, if this polyglot is instead provided to an HTML parser such as a Browser and opened with a .html extension, the Browser will interpret the HTML tags contained in the injected chunk and render their content. For example, the image below shows JavaScript code being executed upon opening the polyglot file.

![Tercera imagen](/assets/img/Polyglot-Post/image3.png)

Moving on to the stack file, it simply concatenated both files.

![Cuarta imagen](/assets/img/Polyglot-Post/image4.png)

We can also do this by just executing:

`echo “<script>alert(‘XSS via polyglot!’)</script>” >> base.png`

Since we’re forging a .png, the server would treat the file as an actual image. This becomes useful if the target application has image viewers that render the file or parse the image using vulnerable libraries or components.

This far, I have shown two files that could coexist, but now I want to go in the opposite direction.

I will show an example where two files are incompatible. This usually happens when one of the files strictly requires its signature to be located at the very beginning of the document, or precisely at offset 0x00, as it is the case with PNG files.

So, let’s see what happens when we try to create a PDF with a PNG file embedded inside. The result is the following:

![Quinta imagen](/assets/img/Polyglot-Post/image5.png)

In this case, Mitra indicates that the PDF can indeed embed another file starting at offset 0x30, which means right after the magic bytes and inside of an object element.

However, this is incompatible with PNGs, as this kind of files must strictly start at offset 0x00. You can think of it as the stricter file type defining the main structure and core of the polyglot, while the more flexible one (in this case, the PDF) is adjusted to fit within that structure. So what would actually be possible is creating a PNG that contains a PDF file inside, not the other way around.

Furthermore, if instead of attaching a PNG we use a simple .sh file, we can see that the payload is successfully injected inside the first PDF object at the specified offset.

![Sexta imagen](/assets/img/Polyglot-Post/image6.png)

By showing these examples we can conclude that any kind of combination fully depends on how flexible the formats are when being combined, from where the signature is required to be located, to which chunks can be used.

**Github**: https://github.com/corkami/mitra

### ExifTool

There are specific scenarios where ExifTool becomes highly useful, particularly when the attack vector involves server-side manipulation of file metadata.

Consider the case of a file upload feature that only validates the magic bytes of the file, accepting only those matching a PNG header, but allows arbitrary extensions.

We could craft a PNG file (with valid magic bytes) but rename it to .php or .jsp and when uploaded, the server might later on interpret it as an executable (PHP/JSP) rather than an image.

Examples:

- <%= System.getProperty(“java.version”) %>

- <?php echo phpversion(); ?>

![Septima imagen](/assets/img/Polyglot-Post/image7.png)

In this example we have a valid png structure and an embedded jsp payload in the file metadata.

Depending on what we are trying to exploit, we may obtain different outputs. If the metadata is displayed in the user interface, it is more likely that we will observe an XSS. On the other hand, if we embed a payload inside an image with the goal of extracting the PHP engine version, the response is more likely to appear in the server response when we request the path of the uploaded image. This is why being able to directly access the uploaded file is an added plus when exploiting these polyglot attack scenarios.

**Github**: https://github.com/exiftool/exiftool

## MIME sniffing
When manipulating files, there’s an important concept to consider: MIME sniffing.

This occurs on the browser when, instead of trusting the Content-Type header provided by the server, it attempts to guess the file type by inspecting the magic bytes.

If we manage to upload a .png file (because only the extension is being validated) but the browser performs MIME sniffing, we could exploit this by crafting a .png whose initial content matches the signatures that browsers identify as HTML/JavaScript during MIME sniffing. This tricks the browser into interpreting our .png as HTML potentially leading to XSS vulnerabilities

In practice, modern browsers significantly restrict MIME sniffing, and many servers send the X-Content-Type-Options: nosniff header by default. However, misconfigurations still occur in real environments, and vulnerabilities continue to be reported when services fail to enforce this header. Some recent examples include:

- CVE-2024–43445

- CVE-2023–36918

- CVE-2018–17031

##Conclusion

In conclusion, Polyglot files can be very sneaky, and they act as a reminder that “file type” can be an interpretation based on a lot of moving parts, very much tied to the complexity of the type of file being ingested and/or interpreted.

As we’ve seen, whether a combination works depends heavily on format flexibility: where magic bytes must appear, which chunks/sections can carry arbitrary data, and how strictly parsers enforce their own specs.

Just to briefly recap, exploitation opportunities may arise through:

- Metadata parsers

- Image processors

- Vulnerable libraries handling file content

- Web server misconfigurations that improperly execute uploaded files

And protecting ourselves against polyglots isn’t a simple task either. It’s an ongoing effort, because keeping parsers and processing libraries up to date matters just as much as validation logic. An effective remediation can involve implementing a Content Disarm and Reconstruction (CDR), which normalizes files by stripping or rebuilding risky structures before they’re stored or processed.

Three steps take place when a file is processed by a CDR. First, the file is disassembled into its core elements (headers, chunks, metadata, comments), and then only the components and attributes required for the legitimate functionality of the file are preserved. You can think of this technology as having a whitelist of which components make up a legitimate type of file (e.g. a PDF). Anything that does not match is removed. The file is then reconstructed using only the components that passed the filter.

Finally, I would like to acknowledge Ange Albertini, creator of the Mitra tool, and Phil Harvey, creator of ExifTool, for making such interesting resources available to the community. These tools inspired me to dive deeper into this topic and I highly encourage exploring their work.
